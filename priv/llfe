#!/usr/bin/env lfe
;;; -*- lfe -*-

;;; =================================================================== [ LLFE ]
;;; This file was generated by LLFE v0.1.0. Do not edit it directly.
;;; ============================================================================

(include-lib "kernel/include/file.hrl")

(include-lib "lfe/include/clj.lfe")

(defun usage ()
  "Print usage tips to the console."
  (io:fwrite (++ "LLFE: Literate Lisp Flavoured Erlang\n"
                 "\n"
                 "Usage: llfe [file]...\n"
                 "       llfe watch [file]...\n"
                 "\n"
                 "Syntax: Literate LFE files are written in Markdown.\n"
                 "        For information about the syntax, please refer to:\n"
                 "        https://github.com/llfe/llfe.\n"
                 "\n"
                 "'llfe watch' takes a list of files. When a change is detected\n"
                 "on any of the files, llfe will automatically re-tangle them.\n"
                 "\n"
                 "There are some debugging functions pertaining to the way the\n"
                 "parser handles documents. Their usage is as follows:\n"
                 "\n"
                 "    llfe print-code [file]\n"
                 "    llfe print-concatenated-code [file]\n"
                 "    llfe print-expanded-code [file]\n"
                 "    llfe print-unescaped-code [file]\n"
                 "    llfe print-file-sections [file]\n"
                 "\n"
                 "For more information, it's probably best to read the literate\n"
                 "source of LLFE itself.\n")))


;;; =============================================================== [ Printing ]

(defun print-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein.
Print all code blocks separately, even if they are continuations."
  (print-sections (all-code (read-file filename))))

(defun print-concatenated-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein,
concatenating any continuations."
  (print-sections (concat-sections (all-code (read-file filename)))))

(defun print-expanded-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein,
concatenating any continuations and expanding any references."
  (-> (all-code (read-file filename))
      (concat-sections)
      (expand-all-sections)
      (expand-all-sections)
      (expand-all-sections)
      (expand-all-sections)
      (print-sections)))

(defun print-unescaped-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein,
concatenating continuations, expanding references and unescaping `<<`."
  (-> (all-code (read-file filename))
      (concat-sections)
      (expand-all-sections)
      (unescape-sections)
      (print-sections)))

(defun print-file-sections (filename)
  "Given a literate LFE `filename`, print and label each code block therein
whose name has the prefix, `file:`, concatenating continuations,
expanding references and unescaping `<<`."
  (-> (all-code (read-file filename))
      (concat-sections)
      (expand-all-sections)
      (unescape-sections)
      (file-sections)
      (print-sections)))

(defun print-sections (sections)
  "Label and print each `` `#(,name ,code) `` in `sections`."
  (lists:foreach
    (lambda (name-code)
      (io:fwrite "~s~n-----~n~s~n-----~n~n" (tuple_to_list name-code)))
    sections))

;;; ============================================================ [ Code blocks ]

(defun collect-to-eol (input)
  (case (lists:splitwith #'not-newline?/1 input)
    (`#(,line [10 . ,rest]) `#(,line ,rest))
    (`#(,line ,rest)        `#(,line ,rest))))

(defun collect-to-fence (input) (collect-to-fence input ""))

(defun collect-to-fence
  ([""                        acc] `#(,(lists:reverse acc) ""))
  ;; 10 = \n
  ([`(10 #\` #\` #\` . ,rest) acc] `#(,(lists:reverse acc) ,rest))
  ([`(,c . ,rest)             acc] (collect-to-fence rest (cons c acc))))

(defun all-code (input) (all-code input ""))

(defun all-code
  ([""                 acc] (lists:reverse acc))
  ([`(10 #\` #\` #\` . ,rest) acc]
   (let* ((`#(,attr ,rest1)  (collect-to-eol rest))
          (`#(match [,name]) (match-name attr))
          (`#(,code ,rest2)  (collect-to-fence rest1)))
     (all-code rest2 `[#(,name ,code) . ,acc])))
  ([`(,_ . ,rest)             acc] (all-code rest acc)))

;;; ================================================ [ noweb-style replacement ]

(defun collect-to-replacement-open (line)
  (collect-to-replacement-open line []))

(defun collect-to-replacement-open
  (["" acc]
   `#(,(lists:reverse acc) ""))
  ([`(#\\ #\< #\< . ,rest) acc]
   (collect-to-replacement-open rest (++ "<<\\" acc)))
  ([`(#\< #\< . ,rest) acc]
   `#(,(lists:reverse acc) ,rest))
  ([`(,c . ,rest) acc]
   (collect-to-replacement-open rest (cons c acc))))

(defun collect-to-replacement-close (input)
  (collect-to-replacement-close input []))

(defun collect-to-replacement-close
  ([""                 acc] `#(,(lists:reverse acc) ""))
  ([`(#\> #\> . ,rest) acc] `#(,(lists:reverse acc) ,rest))
  ([`(,c . ,rest)      acc] (collect-to-replacement-close rest (cons c acc))))

;;; =============================================================== [ Sections ]

(defun concat-sections (sections)
  (flet ((join-section (key)
                       `#(,key ,(unlines (proplists:get_all_values key sections)))))
    (lists:map #'join-section/1 (proplists:get_keys sections))))

(defun split-section (line)
  (case (collect-to-replacement-open line)
    (`#(,_ "") 'nil)
    (`#(,prefix ,rest)
     (let ((`#(,padded-name ,suffix) (collect-to-replacement-close rest)))
       `#(,(string:strip padded-name) ,prefix ,suffix)))))

(defun expand-sections (code sections) (expand-sections code sections []))

(defun expand-sections
  ([""   _sections acc] (unlines (lists:reverse acc)))
  ([code sections  acc]
   (let ((`#(,line ,rest) (collect-to-eol code)))
     (case (split-section line)
       ('nil (expand-sections rest sections (cons line acc)))
       (`#(,name ,prefix ,suffix)
        (case (proplists:get_value name sections)
          ('undefined
           (io:fwrite "Warning: code section named ~p not found.~n" `[,name])
           (expand-sections rest sections (cons (++ prefix suffix) acc)))
          (code-to-insert
           (-> (lists:map (lambda (x) (++ prefix x suffix)) (lines code-to-insert))
               (unlines)
               (cons acc)
               (->> (expand-sections rest sections))))))))))

(defun expand-all-sections (sections)
  (lists:map
    (match-lambda
      ([`#(,name ,code)]
       `#(,name ,(expand-sections code sections))))
    sections))

;;; ======================================================= [ Inspecting files ]

(defun changed-files (a b)
  (lists:filter
    (lambda (x) (=/= (proplists:get_value x a) (proplists:get_value x b)))
    (proplists:get_keys a)))

(defun existing-files (files)
  "Given a list of `files`, return the sublist for which `filelib:is_file/1` holds."
  (lists:filter #'filelib:is_file/1 files))

(defun modified-times (files)
  "Call [[modified-time/1]] on each file in a given list of `files`.
For each file, return a tuple of the form `` `#(,file ,modified-time) ``."
  (lists:map (lambda (file) `#(,file ,(modified-time file))) files))

(defun modified-time (filename)
  "Given a `filename`, return the last time the file was written."
  (let ((`#(ok ,info) (file:read_file_info filename)))
    (file_info-mtime info)))

;;; ========================================================== [ Reading files ]

(defun read-file (filename)
  (case (file:read_file filename)
    (`#(ok ,binary) (binary_to_list binary))
    (`#(error ,reason)
     (io:fwrite "Failed to read file (~s): ~s~n" `[,filename ,reason])
     (error `#(read_file ,filename ,reason)))))

(defun file-sections (sections)
  (lists:filtermap
    (match-lambda
      ([`#(,(= `(#\f #\i #\l #\e #\: . ,_) name) ,code)]
       `#(true #(,name ,code)))
      ([_] 'false))
    sections))

;;; ======================================================= [ Processing files ]

(defun process-files (files)
  (lists:reverse (lists:flatmap #'process-file/1 files)))

(defun process-file (filename)
  (let* ((base-dir          (filename:dirname filename))
         (concatenated-code (concat-sections (all-code (read-file filename))))
         (expanded-code     (-> concatenated-code
                                (expand-all-sections)
                                (expand-all-sections)
                                (expand-all-sections)
                                (expand-all-sections)))
         (files (file-sections (unescape-sections expanded-code))))
    (write-file-sections base-dir files)))

;;; ========================================================== [ Writing files ]

(defun write-file (base-dir filename contents)
  (let ((filename* (file-name base-dir filename)))
    (case (file:write_file filename* (++ contents "\n"))
      ('ok filename*)
      (`#(error ,reason)
       (io:fwrite (++ "Error: Failed to write file (~s): ~s. "
                      "(LLFE doesn't create directories, so you may need to "
                      "create one.)~n")
                  `[,filename* ,reason])))))

;; TODO: handle padline option
(defun write-file-sections (base-dir files)
  (-> (match-lambda
        ([`#((#\f #\i #\l #\e #\: . ,filename) ,contents)]
         (write-file base-dir filename contents)))
      (lists:map files)
      (lists:reverse)))

;;; ========================================================= [ Watching files ]

(defun watch (files f) (watch files f []))

(defun watch (files f state)
  (let* ((modified-times (modified-times (existing-files files)))
         (changed-files  (changed-files modified-times state)))
    (if (> (length changed-files) 0)
      (apply f `[,changed-files])
      'noop)
    (timer:sleep (timer:seconds 1))
    (watch files f modified-times)))

;;; ===================================================== [ Internal functions ]

(defun help? (x)
  "Return `true` iff `x` is one of \"help\", \"-h\", \"-help\" or \"\"--help\"."
  (lists:member x '["help" "-h" "-help" "--help"]))

(defun not-newline?
  "Given a character, return `true` iff it iss not `\\n`."
  ([10] 'false)
  ([_]  'true))

(defun file-name (base-dir filename)
  "Given a `base-dir`ectory and a `filename`, return an absolute path.
The result will be formatted in a way that is accepted by the command shell and
native applications on the current platform."
  (filename:nativename (filename:absname_join base-dir filename)))

(defun match-name (input)
  (re:run input "name=\"(?<name>[^\"]+)\"" '[#(capture [name] list)]))

(defun lines (string)
  "Break a string up into a list of strings at newline characters.
The resulting strings do not contain newlines."
  (re:split string "\n" '[#(return list)]))

(defun unlines (strings)
  "Joins lines, after appending a terminating newline to each.
[[unlines/1]] is an inverse operation to [[lines/1]]."
  (string:join strings "\n"))

(defun unescape (code)
  "Given the contents of a code block, replace any `\"\<<\"` with `\"<<\"`."
  (re:replace code "\\\\<<" "<<" '[global #(return list)]))

(defun unescape-sections (sections)
  "Given a list of sections, call [[unescape/1]] on each code block."
  (lists:map
    (match-lambda ([`#(,name ,code)] `#(,name ,(unescape code))))
    sections))

;;; ======================================================= [ Main entry point ]

(defun main
  (['()] (usage))
  ([`("watch" . ,files)]
   (watch files
          (lambda (changed-files)
            (flet ((print (x) (io:fwrite "~s~n" `[,x])))
              (io:fwrite "\n~s\n" `[,(string:centre " Processing " 30 #\-)])
              (lists:foreach #'print/1 changed-files)
              (io:fwrite "\n~s\n" `[,(string:centre " Output " 30 #\-)])
              (lists:foreach #'print/1 (process-files changed-files))))))
  ([`("print-code"              ,file)] (print-code file))
  ([`("print-concatenated-code" ,file)] (print-concatenated-code file))
  ([`("print-expanded-code"     ,file)] (print-expanded-code file))
  ([`("print-unescaped-code"    ,file)] (print-unescaped-code file))
  ([`("print-file-sections"     ,file)] (print-file-sections file))
  ([args]
   (if (lists:any #'help?/1 args)
     (usage)
     (process-files args))))

(main script-args)

;;; ==================================================================== [ EOF ]
